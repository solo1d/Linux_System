# x86汇编,寄存器

##  X86-64   ATT \(AT&T\)

**整数寄存器 `文件包含16个命名的位置, 分别存储64位的值. 这些寄存器可以存储地址(对应c语言的指针) 或整数数据. 有的寄存器被用来记录某些重要的程序状态,而其他的寄存器用来保存临时数据, 例如过程的参数和局部变量,以及函数的返回值.`**

**条件码寄存器 `保存着近期执行的算数或逻辑指令的状态信息. 他们用来实现控制或数据流中的条件变化, 比如说来实现 if 和 while 语句.`**

**一组向量寄存器`可以存放一个或多个整数或浮点数.`**

**X86-64 的虚拟地址是由 64 位的字来表示的. `(在目前的实现中, 这些地址的高 16位必须设置为0,所以一个地址实际上能够指定的是 2^48 或 64TB 范围内的一个字节)`**

**程序内存包括 `程序的可执行代码, 操作系统需要的一些信息, 用来管理过程调用和返回的运行时栈, 以及用户分配的内存块(比如 malloc 分配的)`**

**操作系统`负责管理虚拟地址空间, 将虚拟地址翻译成实际处理器内存中的物理地址.`** 

**链接器的任务之一 `就是位函数调用找到匹配的函数的可以执行代码的位置.`**

**`所有以 '.' 开头的行 都是指导汇编器和链接器工作的伪指令, 我们通常可以忽略这些行.`**

```ruby
指令;
#调用指令
call     mult2          调用 mult2 代码段.
callq    40058b <mult2> 调用函数 mult2 需要使用的地址(40058b).

#数据传送指令
movb     %rl2b, (%bpl)  将 %rl2b 的内容保存在 %bpl 寄存器的值 所指向的内存的位置上. 1字节
movw     0x00ff,%bx     将内存地址 0x00ff 位置的2字节 复制到 %bx 寄存器中. 2字节
movl     $112,2(,%ebx,2)  将立即数 112 存入  %ebx中的值 乘 2 所得到的 内存地址中. 4字节 (注意会将高4字节置0)
movq     %r12, %rbx     将 %r12 寄存器的值, 复制到 %rbx 寄存器. 8字节
movabsq  $0x64位数,寄存器   只能将64位立即数存入 寄存器,而且只能存入寄存器.(完全可以不使用)

movzbw    %rl2b,%bx     将%rl2b中1字节数据进行高位0拓展,填充到2个字节后 存入到%bx寄存器中.
movzwq    %bx, %r14     将%bx 中的2字节数据进行高位0拓展,填充到4个字节后 存入到%r14 寄存器中.
movsbw    %rl2b,%bx     将%rl2b 中的1字节数据通过最高位来进行拓展(1就推展1,0就推展0),然后存入%bx (2字节)
movslq    %ebx,%rax     将%ebx 中的4字节数据通过最高位进行推展(1就推展1,0就推展0),然后存入%rax  (8字节)

#入栈和出栈 指令
pushq     %rbp      将%rbp寄存器的值 入栈(四字),%rsp保存栈顶指针.向下增长,插入元素之前地址减少8字节,然后再插入.栈顶元素地址最低.
popq      %r12      将栈顶的值出栈(四字),先把栈顶内存值写入%r12寄存器,然后%rsp自增8 ,向上增长,删除栈顶元素,地址增加8字节,栈顶元素比原来的值高.

#算数和逻辑操作指令
#一元操作  (都拥有 qlwb 操作, 指定字节大小)
incq     %rbp           将 %rbp 寄存器的值自增1, 然后再存入 %rbp 寄存器. 
decw     %ax            将 %ax  寄存器的值自减1, 然后再存入 %eax 寄存器.
negl     %eax           减 %eax 寄存器的值 进行取负操作,再存入 %rbx 寄存器 ( 2 -> -2)
notd     %al            将 %al  寄存器的值 进行取反操作,再存入 %rbx 寄存器 (1010 -> 0101)

#一元操作 --乘法运算
  #下面乘法指令运行后的结果 高位存放在%rdx中  低位存放在%rax中, 一共是128位 (16个字节)
  #在执行这条指令前, 必须有一个运算参数在 %rax寄存器中,而另一个参数作为指令的源操作数给出.
imulq    %rbx      有符号乘法运算, 后面的q指定四字运算.%rbx的值会被当初参数,与%rax寄存器的值
                     进行运算, 然后乘积的值是128位(16字节),将高位放在%rdx中,低位放在%rax中.
                     也就是说 指令前有 movq一条指令,后面有两条movq指令, 分别进行取出和放入.
                      #例子:   long x,y;   long * d;  
                      #        typedef unsigned __int128 uint128_t;   存放16字节的值
                      #       *d = x * (uint128_t) y;
                      #   d 是 %rdi, x 是%rsi  , y 是%rdx    #
                      #       movq   %rsi, %rax     拷贝x值到%rax寄存器(必须是这个寄存器)
                      #       mulq   %rdx           y与x进行乘法运算,结果默认存入了%rdx和%rax中
                      #       movq   %rax, (%rdi)   将低位的%rax放入 d 的低位地址(小端表示法,从高到低读)
                      #       movq   %rdx, 8(%rdi)  将高位的%rdx放入 d+8 的高位地址(高存高,低存低)
                      #       ret
mulq     %rbx      无符号乘法运算, 后面的q指定四字运算, 和上面相同, 只不过是符号问题罢了

#一元操作 --除法运算
  #除法指令完成后的商保存在 %rax 中, 余数存保存在 %rdx 中.
  #被除数保存在 %rdx 寄存器中,而且必须在指令前把被除数保存进去. 然后再使用 cqto 指令进行有符号除法拓展.
    # 当使用无符号除法 divq 时, 不应该使用 cqto  指令, 应该手动初始化 %rdx 为全0.
  #除数参数 应该当作源操作数传递给 idivq或divq 除法指令.
cqto         没有操作数,这条指令隐含读出 %rax 的符号位,并将它复制到 %rdx的所有位. 一般出现在有符号除法指令之前.
idivq   %rsi     有符号除法,在这条指令之前需要使用cqto 指令, 然后被除数复制到%rdx中.
                    #例:  long x,y,q,r;     long *qp, *rp; 
                    #     q = x/y ;  r = x%y ;  *qp = q; *rp = r;
                    # x是%rdi, y是%rsi, qp是%rdx, rp是%rcx   # 注意:qp占用了%rdx
                    #  movq   %rdx,%r8    因为qp占用了%rdx 余数寄存器,所以要将原值另存它处
                    #  movq   %rdi,%rax   把被除数x 保存到%rax 被除数寄存器中.
                    #  cqto               因为是有符号除法,所以需要这个来进行符号推展 %rdx
                    #  idivq  %rsi        进行除法,%rax和%rdx是被除数,%rsi是除数.结果的商保存在%rax,余数%rdx
                    #  movq   %rax,(%r8)  将商保存到%r8所指向的内存位置. %rax保存着商.
                    #  movq   %rdx,(%rcx) 将余数给%rcx指向的内存位置,也就是 *rp=x%y; 取模和除法余数结果相等.(优化了)
                    #  ret                没有返回值.直接退出返回上层.
divq    %rsi     无符号除法,大部分操作和有符号相同,但是 cqto 指令变成 movq $0,%rdx .


# 二元操作 --整数运算  (也全都拥有 qlwb 操作, 指定运算字节大小)
subq     $8,%rbp        减法运算, 将%rbp寄存器的值 减去8 这个立即数,然后结果存入%rsp寄存器. 四字运算
                         除此之外还有 subb , subw, subl , 分别是 字节减法,字减法,双字减法
addq     $8,%rbp        加法运算, 将%rbp寄存器的值 加上8 这个立即数,然后结果存入%rsp寄存器. 四字运算
                         除此之外还有 addb , addw, addl , 分别是 字节加法,字加法,双字加法
   
#二元操作 --位运算
xor      %rax,%rbx      异或
or       %rax,%rbx      或
and      %rax,%rbx      与

#移位操作 (第一个操作数必须使用%cl寄存器,或者立即数$,也是有qwlb操作)
#(当寄存器%cl 为 0xff 时,salb会移位7位,salw会移位15位,sall会移位31位, salq会移位63位, 根据qwbl操作会忽略%cl高位)
salb      %cl,%rbx     左移逻辑操作,因为指令尾数是b 所以最多可以位移7位, 将%rbx的值进行位移,然后再存入%rbx
shlw      $12,%rbx     也是左移逻辑操作和sal一摸一摸 没区别, 但是注意 qwlb 只针对 目的操作数,不针对源操作数.
sarl      $3,%rbx      右移算数操作, 进行算数右移, 会补最高位置的值,l表示最多位移31位, 2^5 -1=31
shrq      %cl,%rbx     右移逻辑操作, 进行逻辑右移, 最高位补0. q表示最多移位63位, 2^6 -1 = 63

#加载有效地址
leaq  (%rdi,%rsi,4), %rax   计算前面的源操作数(不是地址),将得到的数据写入 %rax ( 目的操作数必须是寄存器)
                             比如 %rdi =2,%ris=3 通过计算 2+3*4 = 14 那么%rax = 14

#返回指令
ret                     return

nop                     作用是使函数代码变为16字节,提升存储器系统性能,更好放置下个代码块.



############################################################################
############################################################################
############################################################################

寄存器;

%rip     表示pc程序计数器,给出将要执行的下一条指令在内存中的地址.

X86-64有16个64位通用寄存器，分别是：
%rax         作为函数返回值使用。
%rbx ,%rbp ,%r12，%r13，%14，%15   用作数据存储，遵循被调用者使用规则
                                     简单说就是随便用，调用子函数之前要备份它，以防他被修改
%rdi ,%rsi ,%rdx ,%rcx ,%r8，%r9  作为函数参数, 依次对应第1参数，第2参数....
%rsp         栈指针寄存器，指向栈顶.
%r10，%r11   用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值.
```

### 寄存器

![16&#x4E2A;&#x901A;&#x7528;&#x5BC4;&#x5B58;&#x5668;](.gitbook/assets/ji-cun-qi.png)

```ruby
%rip     表示pc程序计数器,给出将要执行的下一条指令在内存中的地址.

X86-64有16个64位通用寄存器，分别是：
%rax         作为函数返回值使用。
%rbx ,%rbp ,%r12，%r13，%14，%15   用作数据存储，遵循被调用者使用规则
                                     简单说就是随便用，调用子函数之前要备份它，以防他被修改
%rdi ,%rsi ,%rdx ,%rcx ,%r8，%r9  作为函数参数, 依次对应第1参数，第2参数....
%rsp         栈指针寄存器，指向栈顶.
%r10，%r11   用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值.
```

* **指令可以对这 16 个寄存器的低位字节中存放的不同大小的数据进行操作.**
  * 8位操作可以访问最低的1个字节.
  * 16位操作可以访问最低的2个字节.
  * 32位操作可以访问最低的4个字节.
  * 64位操作可以访问整个寄存器. 8个字节.
* **生成和赋值字节规则**
  * 生成1字节和2字节数字的指令会保持剩下的字节`不变`;
  * 生成4字节数字的指令会把高位4个字节`置为0;`

\*\*\*\*

### C语言数据类型在x86-64 中的大小.  \(在64位机器中,指针长8字节\)

| C声明 | Intel 数据类型 | 汇编代码后辍 | 大小\(字节\) |
| :---: | :---: | :---: | :---: |
| char | 字节 | b  \(例如: movb\) | 1 |
| short | 字 | w  \(例如: movw\) | 2 |
| int | 双字 | l  \(例如: movl\) | 4 |
| long | 四字 | q  \(例如: movq\) | 8 |
| char\* | 四字 | q  \(例如: \) | 8 |
| float | 单精度 | s  \(例如: \) | 4 |
| double | 双精度 | l  \(例如: \) | 8 |

### Intel 和 ATT 格式的不同

**编译出 intel 格式汇编的命令  :  `gcc   -S  -masm=intel  mstore.c`**

* **intel 代码省略了指示大小的后辍.**  指令是 `push` 和 `mov`,  而不是 `pushq` 和 `movq`.
* **intel 代码省略了寄存器名字前面的 '`%` ' 符号**, 用的是  `rbx` ,而不是 `%rbx`
* **intel 代码用不同的方式来描述内存中的位置**.  例如是 '`QWORD PIR [rbx]` ' 而不是 '`(%rbx)`' .
* **在带有多个操作数的情况下, 列出操作数的顺序相反.**  `mov  a ,b`  是a被赋值, `movp a,b` 是b被赋值.

### 在C程序中插入汇编的两种方法

1. 编写完整的函数, 放进一个独立的汇编代码文件中, 让汇编器和链接器把它和用C语言书写的代码合并起来.
2. 使用gcc的内联汇编, 用 sam伪指令可以在C程序中包含简短的汇编代码.\(缺少灵活性和可移植性\).











