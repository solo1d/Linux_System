# 过程 \(栈\)

## 过程

**过程在软件中是一种很重要的抽象**. 它提供了一种封装代码的方式, 用一组指定的参数和一个可选的返回值实现了某种功能.

* **传递控制**
  * **`假设过程P调用过程Q.`** `当进入过程Q的时候, 程序计数器必须被设置为Q的代码的起始地址,然后在返回时,要把程序计数器设置为P中调用Q后面那条指令的地址.`
* **传递数据**
  * `P必须能够向Q提供一个或多个参数, Q必须能够向P返回一个值.`
* **分配和释放内存**
  * `在开始的时候,Q可能需要为局部变量分配空间,而在返回之前又必须释放这些存储空间.`

程序可以用**`栈`**来管理它的过程所需要的**`存储空间`**, **`栈`**和**`程序寄存器`**存放着**`传递控制`**和**`数据`**,**`分配内存`**所需要的**信息**.

x86-64的栈**向低地址方向增长**, 而栈指针 **`%rsp`** 指向栈顶元素.

将栈指针**`减小`**一个适当的量可以为**`没有指定初始值的数据`**在栈上**分配空间**. 类似的,可以通过**`增加`**栈指针来**`释放空间`**.

当x86-64过程需要的存储空间超过寄存器能够存放的大小时,就会在栈上分配空间,这个部分称为过程的**`栈帧.`**

```ruby
入栈和出栈指令:   ( 栈顶指针 %rsp )
pushq    %rdx    将%rdx寄存器的值入栈.栈指针首先会-8,然后将%rdx的值放入栈指针指向的位置中.
popq     %r12    将栈顶元素的值弹出并赋值给%r12寄存器, 首先取出栈顶值,赋给%r12,然后栈指针+8

调用和返回指令:   (PC 寄存器是 %rip , 下面三条指令有没有q 都一样)
callq    .L1        直接调用, 首先会把调用者callq的下条指令的地址压入栈中, 然后将被调用者的
                       起始地址赋值给PC. (压入的地址称为 返回地址 )
callq    *(%rdi)    间接调用.
retq                返回指令, 将callq指令压入栈中的地址取出来, 赋值给PC. 回到了调用者的位置.
```

### 栈上局部存储

一般来说, 通过减小栈指针在栈上分配空间. 分配的结果作为栈帧的一部分,标号为 "**局部变量**".

* 有些时候局部数据必须存放在内存中, 常见的情况有以下几种:
  * 寄存器不足够存放所有的本地数据.
  * 对一个局部变量使用地址运算符 &  ,因此必须能够为它产生一个地址.
  * 某些局部变量是数组或者结构, 因此必须能够通过数组或结构引用被访问到.















