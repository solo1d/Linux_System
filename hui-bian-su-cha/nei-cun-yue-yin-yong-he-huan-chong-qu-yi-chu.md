# 内存越界引用和缓冲区溢出

## 内存越界引用和缓冲区溢出

C 对数组引用不进行任何边界检查, 而且局部变量和状态信息\( 例如保存在寄存器中的值和返回地址\) 都存放在栈中.

对越界的数组元素的写操作会破坏存储在栈中的状态信息.

一种特别常见的状态破坏状态称为**`缓冲区溢出(buffer overflow).`**

```c
/* 通常,在栈中分配某个字符数组来保存一个字符串, 但是字符串的长度超出了为数据分配的空间 ;下面是个事例*/

/*  库函数的实现get（）,这个函数问题是:没办法确定是否为保存整个字符串分配了足够的空间 */
char* gets(char* s){
    int c;
    char* dest = s;
    while( (c = getchar()) != '\n'  && c != EOF )
        *dest++ = c;       /* 先解指针,然后将c传入, 再把指针值+1, 指向下一个元素 */
    if( c == EOF && dest == s)
          return NULL;      /* 没有读取的内容 */
      *dest ++ = '\0';     /* 终止字符串标示 */
      return s;
  }
/* 读取输入行并将其写回 */
void echo(){
    char buf[8];    /* 任何长度超过7个字符的字符串都会导致写越界 (最后有个 '\0' )*/ 
    gits(buf):
    push(buf);
}




/* echo 函数 所产生的汇编代码, 实际给buf 分了8个字节空间, 但是又预留了8个, 总共16字节空间 */
echo:
    subq     $24,%rsp        申请24 个字节的栈空间,8个是返回值,8个来存放buf,和8个未使用的空间.
    movq     %rsp,%rdi       将char buf 的地址当作参数传入 gets 函数
    call     gets            调用gets 函数
    movq     %rsp,%rdi       同上
    call     puts            同上
    add      $24,%rsp        释放栈空间
    ret
```

![&#x5F53;buf &#x5B58;&#x50A8;&#x7684;&#x5185;&#x5BB9;&#x8D85;&#x8FC7;7&#x4E2A;&#x65F6;&#x7684;&#x72B6;&#x6001;](../.gitbook/assets/ping-mu-kuai-zhao-20190805-17.37.14.png)

* 0 ~ 7      **`不会有影响`**
* 9 ~ 23    **`会覆盖未被使用的预留8字节的空间, 但是无法读取出来.`**
* 24 ~ 31  **`会覆盖call 调用的时候所保存的 %rip 寄存器(PC), echo函数的返回地址`**
* 32 +        **`会覆盖 caller(栈帧)中保存的状态, 后果非常严重.`**















