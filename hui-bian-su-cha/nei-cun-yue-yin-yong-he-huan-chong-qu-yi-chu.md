# 内存越界引用和缓冲区溢出

## 内存越界引用和缓冲区溢出

C 对数组引用不进行任何边界检查, 而且局部变量和状态信息\( 例如保存在寄存器中的值和返回地址\) 都存放在栈中.

对越界的数组元素的写操作会破坏存储在栈中的状态信息.

一种特别常见的状态破坏状态称为**`缓冲区溢出(buffer overflow).`**

```c
/* 通常,在栈中分配某个字符数组来保存一个字符串, 但是字符串的长度超出了为数据分配的空间 ;下面是个事例*/

/*  库函数的实现get（）,这个函数问题是:没办法确定是否为保存整个字符串分配了足够的空间 */
char* gets(char* s){
    int c;
    char* dest = s;
    while( (c = getchar()) != '\n'  && c != EOF )
        *dest++ = c;       /* 先解指针,然后将c传入, 再把指针值+1, 指向下一个元素 */
    if( c == EOF && dest == s)
          return NULL;      /* 没有读取的内容 */
      *dest ++ = '\0';     /* 终止字符串标示 */
      return s;
  }
/* 读取输入行并将其写回 */
void echo(){
    char buf[8];    /* 任何长度超过7个字符的字符串都会导致写越界 (最后有个 '\0' )*/ 
    gits(buf):
    push(buf);
}
```























