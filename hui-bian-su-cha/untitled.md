# x86汇编 条件码指令, 跳转指令

包括  **`条件码寄存器指令`**, **`跳转指令`**

## 控制 和 指令 以及条件码寄存器

**与`数据相关的控制流`是实现有`条件行为`的更一般和更常见的方法.**

* 两种控制流
  * **测试数据值**
    * **`根据测试的结果来改变控制流或者数据流.`**

**除了整数寄存器, CPU还维护着一组单个位的条件码寄存器\(condition code\).**

### 条件码寄存器

* **条件码寄存器** 
  * **`他们描述了最近的算数和逻辑操作的属性.`**
  * **`可以检测这些寄存器来执行条件分支指令.`**
  * **`所有的算数和逻辑操作都会设置条件码.`**
  * **条件码通常不会直接读取,常用的使用方式有3种:**
    * 可以根据条件码的某种组合,将一个字节设置成0 或者1.
    * 可以条件跳转到程序的某个其他部分.
    * 可以有条件地传送数据.
  * **常用条件码有:**
    * **CF  :**进位标志.   **`最近的操作使最高位产生了进位`. `可以用来检查无符号操作的溢出`.**
      * `(unsigned ) t  <  (unsigned) a`
    * **ZF  :**零标志.       **`最近的操作得出的结果为0`.**
      * `(t == 0)`
    * **SF**  :符号标志.   **`最近的操作得到的结果为负数.`**
      * `(t < 0 )`
    * **OF** :溢出标志.    **`最近的操作导致一个补码溢出 -- 正溢出或负溢出.`**
      * `(a<0 == b<0) && (t<0 != a<0)`

## 条件码指令

```ruby
leaq  指令不会改变任何条件码, 因为它是用来进行地址计算的. 除此之外其余的都会改变条件码.
xor   指令进位标志CF 和溢出标志OF 会设置成0.
      对于位移操作, 进位标志CF 将设为最后一个被移出的位, 而溢出标志OF 会设置为0.
inc 和 dec 指令会设置溢出OF 和 零标志ZF ,但是不会改变进位标志CF.


#设置条件码指令 (不会改变任何寄存器,只设置条件码),都拥有 pwlb操作(1,2,4,8 字节格式)
cmpb   %al,%bl     根据两个操作数之差来设置条件码,类似于sub指令,进行减法 %bl-%al, 可以查看ZF,SF,OF,CF 对比大小.
testw  %ax,%ax     根据两个操作数的 与运算 来设置,%ax & %ax, 可以查看SF,ZF 得到是负数还是0


#访问条件码(注意set指令的后辍与其他的不一样,表示的是不同的条件 而不是操作数大小),考虑的是条件码的组合
#所有set指令的 目的操作数必须是 低位单字节存储器元素之一(%al,%bl),或是一个字节的内存位置, 
#   指令会将这个字节设置为0或者1, 为了得到一个32位或者64位结果, 则必须对高位清零.
#  所有set指令执行之前都会执行上面的设置条件码指令, 具体的组合根据情况判断.
#  这个判断的机制和所需参数都是 来自上一条指令执行之后的 条件码的数值. (cmpq 或 testq).
#   再将得到的 %al 数值高位 置0,  <  movzbl %al ,%eax  >

set     %al   同义名 sete , 操作 %al <- ZF , 判断是否相等 (a==b) 有无符号都可以
setne   %al   同义名 setnz, 操作 %al <- (~ZF), 判断是否不相等(a!= b) 有无符号都可
sets    %al   没有同义名, 操作 %al <- SF , 判断是否是负数,就是小于0. (t<0) 有无符号都可以
setns   %al   没有同义名, 操作 %al <- (~SF), 判断是否是非负数. (t>0) 有无符号都可以

setg    %al   同义名 setnle, 操作 %al <- (~(SF^OF)& (~ZF) , 有符号 大于 ( a > b )有
setge   %al   同义名 setnl , 操作 %al <- (~(SF^OF)) ,  有符号 大于等于  ( a >= b )有
setl    %al   同义名 setnge, 操作 %al <- SF^OF , 有符号 小于 ( a < b)有
setle   %al   同义名 setng,  操作 %al <- (SF^OF)|ZF , 有符号 小于等于 ( a <= b)有

seta    %al   同义名 setnbe, 操作 %al <- (~CF) & (~ZF) , 无符号 超过 ( A > B )无
setae   %al   同义名 setnb,  操作 %al <- ~CF , 无符号 超过或相等 ( A >= B)无
setb    %al   同义名 setnae, 操作 %al <- CF , 无符号 低于  ( A < B)无
setbe   %al   同义名 setna , 操作 %al <- CF|ZF , 无符号 低于或相等 ( A <= B )无

#同义名和指令名功能相同, 编译器和反汇编器会随意决定该使用哪一个.

例子#
    c代码:  int comp(long a, long b) {   return a < b;   }
     汇编:  comp:     #a是寄存器 %rdi,  b是%rsi
               cmpq    %rsi,%rdi        #条件码指令,执行 a-b 重置条件码,但不修改寄存器
               setl    %al              #查看SF和OF条件码. SF^OF 得到的 1 或0 写入%al
               movzbl  %al,%eax         #将%al 无符号0补全,写入%eax,因为是l 所以高4位也置0.
               ret                      #%eax 被拓展之后是 %rax  就是返回值参数寄存器.
```

## 跳转指令

```ruby
#无条件跳转指令, 
jmp   操作数     # 无条件跳转指令, 有下面两种情况
jmp   .L1        #一.直接跳转(既跳转目标是作为指令的一部分编码的,格式: .标号)
                  #用标号当跳转目标.
jmp   *%rax      #二.间接跳转(即跳转目标是从寄存器或内存位置中读出的,格式: *操作数指示符)
                  # 用寄存器 %rax的值作为跳转目标. 
jmp   *(%rax)    #跳转到 寄存器存储值 所指向 的内存地址中取出跳转目标 并跳转执行.


#有条件跳转指令(直接跳转), 他们都和 条件码相关  CF进位 ,ZF零 ,OF溢出 ,SF符号
# 满足后面的计算条件  就会跳转, 如果不满足则继续执行序列中下一条指令.
je   .L1       #同义名jz , 操作  ZF  ,相等/零
jne  .L1       #同义名jnz, 操作  ~ZF  ,不想等/非零

js   .L1       #没有同义名. 操作  SF   ,负数
jns  .L1       #没有同义名. 操作  ~SF  ,非负数

jg   .L1       #同义名jnle, 操作 ~(SF^OF)& ~ZF  , 有符号 大于  ( > )
jge  .L1       #同义名jnl , 操作 ~(SF^OF)       , 有符号 大于或等于 ( >= )
jl   .L1       #同义名jnge, 操作 SF^OF          , 有符号 小于  ( < )
jle  .L1       #同义名jng , 操作 (SF^OF)|ZF     , 有符号 小于或等于 ( <= )

ja   .L1       #同义名jnbe, 操作 ~CF & ~ZF   ,无符号  超过 ( > )
jae  .L1       #同义名jnb , 操作 ~CF         ,无符号  超过或相等 ( >= )
jb   .L1       #同义名jnae, 操作 CF          ,无符号  低于 ( < )
jbe  .L1       #同义名jna , 操作 CF | ZF     ,无符号  低于或相等 ( <= )


# repz retp  指令的组合很重要,可以加快处理速度.只可以出现在 跳转指令之后,函数的最后两条指令.
例子
    movq   %rdi, %rax       
    jmp    .L2            无条件跳转到L2
 .L3:
    sarq   %rax
 .L2:
    testq  %rax,%rax      并运算, 得到原来的值, 重置条件码
    jg     .L3            有条件跳转, 操作  ~(SF^OF)& ~ZF
    rep; ret              rep和repz 同义名, ret和retp 同义名
    
详细解析 十六进制反汇编:  (PC 值很重要,它指向下条指令的地址)
     地址   十六进制机器代码    指令   操作数
     0x0:   48 89 f8         mov   %rdi,%rax
     0x3:   eb 03            jmp   8 <loop + 0x8>     #0x3 + 0x5 = 0x8 地址计算
     0x5:   48 d1 f8         sar   %rax
     0x8:   48 85 c0         test  %rax,%rax
     0xb:   7f f8            jg    5 <loop + 0x5>     #0xf8 + 0xd = 0x5 地址计算
     0xd:   f3 c3            repz retq                #retq返回 前面有个repz 很重要.
```

在生成目标代码文件时, 汇编器会确定所有带标号指令的地址,  并将**`跳转目标`**\(目的指令的地址\)编码为跳转指令的一部分.











