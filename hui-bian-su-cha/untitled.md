# x86汇编 控制指令,条件码

包括 

## 控制 和 指令 以及条件码寄存器

**与`数据相关的控制流`是实现有`条件行为`的更一般和更常见的方法.**

* 两种控制流
  * **测试数据值**
    * **`根据测试的结果来改变控制流或者数据流.`**

**除了整数寄存器, CPU还维护着一组单个位的条件码寄存器\(condition code\).**

### 条件码寄存器

* **条件码寄存器** 
  * **`他们描述了最近的算数和逻辑操作的属性.`**
  * **`可以检测这些寄存器来执行条件分支指令.`**
  * **条件码通常不会直接读取,常用的使用方式有3种:**
    * 可以根据条件码的某种组合,将一个字节设置成0 或者1.
    * 可以条件跳转到程序的某个其他部分.
    * 可以有条件地传送数据.
  * **常用条件码有:**
    * **CF  :**进位标志.   `最近的操作使最高位产生了进位`. `可以用来检查无符号操作的溢出`.
    * **ZF  :**零标志.       `最近的操作得出的结果为0`.
    * **SF**  :符号标志.   `最近的操作得到的结果为负数.`
    * **OF** :溢出标志.    `最近的操作导致一个补码溢出 -- 正溢出或负溢出.`

### 指令

```ruby
leaq  指令不会改变任何条件码, 因为它是用来进行地址计算的. 除此之外其余的都会改变条件码.
xor   指令进位标志CF 和溢出标志OF 会设置成0.
      对于位移操作, 进位标志CF 将设为最后一个被移出的位, 而溢出标志OF 会设置为0.
inc 和 dec 指令会设置溢出OF 和 零标志ZF ,但是不会改变进位标志CF.


#设置条件码指令 (不会改变任何寄存器,只设置条件码),都拥有 pwlb操作(1,2,4,8 字节格式)
cmpb        根据两个操作数之差来设置条件码,类似于sub指令,进行减法
testw       

#访问条件码 (注意 set指令的后辍与其他的不一样, 表示的是不同的条件 而不是操作数大小),考虑的是条件码的组合
set  %al    目的操作数是低位单字节存储器元素之一(%al,%bl),或是一个字节的内存位置, 
              指令会将这个字节设置为0或者1.

setb      低于时设置
setl      小于时设置
setw       
setq      




```















