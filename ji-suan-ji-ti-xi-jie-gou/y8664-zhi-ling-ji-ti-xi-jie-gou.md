# Y86-64 指令集体系结构

**定义一个指令集体系结构\(例如 Y86-64\), 包括`定义各种状态单元`, `指令集`和`它们的编码`, `一组编程规范`和`异常事件处理`.**

## 程序员可见的状态

**Y86-64 程序中的每条指令都会读取或修改处理器状态的某些部分,** 这称为**`程序员可见状态`**`(这里的程序员指的是 即可用汇编代码编写程序的人,也可以是产生机器级代码的编译器).`

在处理器实现中,只要我们**保证机器级程序能够访问程序员可见状态**,就不需要完全按照ISA暗示的方式来表达和组织这个处理器状态.

**Y86-68的状态也类似于 x86-64,有15个寄存器**: **`%rax,%rcx,%rdx,%rbx,%rsp,%rsi,%rdi,%r8到%14`**. \(每个寄存器存储一个**`64位`**的字, 寄存器**`%rsp 被入栈,出栈,调用和返回指令作为栈指针`**, 除此之外,**寄存器没有固定的含义和固定值.** 

有三个1位的**条件码: `ZF(零), SF(负)和 OF(溢出),`** 它们保存着最近的算数和逻辑指令所造成影响的有关信息. **`程序计数器(PC) 存放`**`当前正在执行指令的地址.(%rip)`

内存从概念上来讲就是一个很大的字节数组, **`保存着程序和数据`**, Y86-64用**`虚拟地址来引用内存位置`**.  **硬件和操作系统联合起来将虚拟地址翻译成实际或物理地址**,  **指明数据实际存在内存中哪个地方.**\(认为虚拟内系统向Y86-64提供了**一个单一的字节数据映像\)**

**程序状态的最后一个部分是状态码 `Stat`, 它表明程序执行的总体状态. 它会指示是正常运行还是出现某种异常.**\(例如当一条指令试图去读非法的内存地址使\)

![&#x7A0B;&#x5E8F;&#x5458;&#x53EF;&#x89C1;&#x72B6;&#x6001;&#x548C;&#x5BC4;&#x5B58;&#x5668;](../.gitbook/assets/ping-mu-kuai-zhao-20190810-16.17.41.png)

### Y86-64 指令

































