# 进程

## 进程

* **`异常`**是允许操作系统提供`进程`的概念的基本构造快,`进程`是计算机科学中最深刻，最成功的概念之一。
  * 假象，觉得我们的程序是系统中唯一运行着的程序。我们的程序好像独占处理器和存储器。
  * 这些假象都是通过进程概念提供给我们的。
* `进程`经典定义：一个执行中的程序实例.
  * 系统中每个程序都是运行某个进程的`上下文`中的。
    * 上下文是由程序正确运行所需的状态组成。
    * 这个状态包括存储器中的代码和数据，它的栈，通用目的寄存器，程序计数器，环境变量等。
* `进程`提供的假象
  * 一个独立的`逻辑控制流`。
  * 一个私有的`地址空间`。

### 逻辑控制流

* PC值的序列叫做`逻辑控制流`，或者简称`逻辑流`

![](../.gitbook/assets/ping-mu-kuai-zhao-20190902-xia-wu-7.10.40.png)

### 并发流



* `逻辑流`也有不同的形式。
  * 异常处理程序，进程，信号处理程序，线程和Java进程都是逻辑流的例子。
* 一个逻辑流的执行在执行上与另一个流重叠，称为`并发流`，这两个流被称为**并发地运行**。
  * 更准确地说，流X和Y互相并发。
* 多个流并发执行的一般现象称为`并发`。
  * 一个进程和其他进程轮流执行的概念称为`多任务`。
  * 一个进程执行它的控制流的一部分的每一时间段叫做`时间片`。
  * 因此，**多任务** 又叫`时间分片`
* `并发`的思想与流运行的处理器核数与计算机数无关。
  * 如果两个流在时间上重叠，即使运行在同一处理器，也是并发。
  * 并行流是并发流的一个真子集。
    * 两个流并发地运行在不同的处理器核或者计算机上，我们称为`并行流`。
    * 它们并行地运行，且并行地执行

> **你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持`并发`也不支持`并行`。**

> **你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持`并发`。**

> **你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持`并行`。**

> **`并发`的关键是你有处理多个任务的能力，不一定要同时。**

> **`并行`的关键是你有同时处理多个任务的能力。**

### **私有地址空间**

`进程` 为个程序好像独占了系统地址空间。

* 一个`进程`为每个程序提供它自己的**私有地址空间**。
* 不同系统一般都用相同的结构。

![](http://i.imgur.com/O0hyaPF.png)

### 用户模式和内核模式

**处理器提供一种机制，限制一个应用程序可以执行的指令以及它可以访问的地址空间范围。这就是`用户模式`和`内核模式`。**

* 处理器通过控制寄存器中的一个`模式位`来提供这个功能。
  * 该寄存器描述了进程当前享有的特权。
    * 设置了`模式位`后，进程就运行在内核模式中\(有时也叫`超级用户模式`\)
      * 内核模式下的进程可以执行指令集的任何指令，访问系统所有存储器的位置。
    * 没有设置`模式位`时，进程运行在用户模式。
      * 用户模式不允许程序执行特权指令。
        * 比如停止处理器，改变模式位，发起一个I/O操作。
      * 不允许用户模式的进程直接引用地址空间的内核区代码和数据。
      * 任何尝试都会导致`保护故障`。
      * 用户通过`系统调用`间接访问内核代码和数据。
  * 进程从用户模式转变位内核模式的方法
    * 通过中断，故障，陷入系统调用这样的异常。
    * 在异常处理程序中会进入内核模式。退出后，又返回用户模式。
* Linux提供一种聪明的机制，叫`/proc`文件系统。
  * 允许用户模式访问内核数据结构的内容。
  * `/proc`文件将许多内核数据结构输出为一个用户程序可以读的文本文件的层次结构。
    * 如CPU类型\(`/proc/cpuinfo`\)
    * 特殊进程使用的存储器段\('/proc//maps'\)
  * 2.6 版本引入Linux内核引入`/sys`文件系统。
    * 输出关于系统总线和设备的额外的底层信息。

### 上下文切换

**操作系统内核使用一种称为上下文切换的 较高层次 的异常控制流来实现多任务。**

* 上下文切换机制建立在之前讨论的较低层次异常机制上的。

**内核为每个进程维护一个上下文。**

* 上下文就是重新启动一个被抢占的进程所需的状态。
  * 由一些对象的值组成
    * 通用目的寄存器
    * 浮点寄存器
    * 程序计数器（PC\)
    * 用户栈
    * 状态寄存器
    * 内核栈
    * 各种内核数据结构
      * 描绘地址空间的**页表**
      * 包含当前进程信息的**进程表**
      * 进程已打开文件信息的**文件表**
* 在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程。这种决定叫做**调度**\(`shedule`\),由内核中称为**调度器**\(`scheduler`\)的代码处理的。
  * 当内核选择一个新的进程运行时，我们就说内核**调度**了这个进程。
* 当调度进程时，使用一种`上下文切换`的机制来控制转移到新的进程
  * 保存当前进程的上下文
  * 恢复某个先前被抢占的进程被保存的上下文
  * 将控制传递给这个新恢复的进程
* 什么时候会发生上下文切换
  * 内核代表用户执行**系统调用**。
    * 如果系统调用因为某个事件**阻塞**，那么内核可以让当前进程休眠，切换另一个进程。
    * 或者可以用`sleep`系统调用，**显式**请求让调用进程休眠。
    * 即使系统调用没有阻塞，内核可以决定执行上下文切换
  * 中断也可能引发上下文切换。
    * 所有系统都有某种产生**周期性定时器中断**的机制，典型为1ms，或10ms。
    * 每次定时器中断，内核就能判断当前进程运行了足够长的时间，**切换新的进程**。

> **高速缓存污染和异常控制流**

> 一般而言，硬件高速缓存存储器不能和诸如中断和上下文切换这样的异常控制流很好地交互，如果当前进程被一个中断暂时中断，那么对于中断处理程序来说高速缓存器是冷的。如果处理程序从主存访问足够多的表项，被中断的进程继续的时候，高速缓存对于它来说也是冷的，我们称**中断处理程序**污染了**高速缓存**。使用 **上下文切换**也会发生类似的现象。

## 系统调用错误处理

* 当Unix系统级函数遇到错误时，他们典型地**返回-1**，并**设置**全局变量`errno`来表示什么出错了。

  ```text
    if((pid=fork()<0){
            fprintf(stderr,"fork error: %s\n", strerror(errno));
            exit(0);
    }
  ```

* strerror 函数返回一个文本串，描述了个某个errno值相关联的错误。

## 进程控制



































